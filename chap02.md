# ch02: 마이크로컴퓨터 하드웨어

### 임베디드 시스템의 구성
* 임베디드 시스템: 하드웨어와 소프트웨어가 기기에 내장되어 있는 시스템
* 기능이 정해진 목적에 따라 구성되어 전용의 동작을 하므로, 기능이 중도에 바뀔 일이 없음
* 소프트/하드 리얼타임은 시간 제약을 여겼을때의 허용여부로 결정된다

### 임베디드 마이크로컴퓨터의 구성
* 하드웨어의 종류: CPU, 메모리, 주변장치(Peripheral)
    *이러한 하드웨어를 하나로 만든 것이 마이크로컴퓨터
* 메모리: ROM과 RAM이 있다
* CPU: 계산에 필요한 부품(ex: ALU)등을 하나의 칩으로 합쳐 놓은 것
* 주변장치: 마이크로컴퓨터 기능을 확장시키기 위해 추가되었다
* CPU와 주변장치는 버스를 통해 소통한다
* ROM은 저장소, RAM은 버퍼의 역할을 수행한다
* 메모리의 종류는.. 메모리와 반도체를 공부해서 좀 더 정리하자..
* 버스: 메인버스 + 로컬버스; 고속 동작은 메인 버스에서 수행, 주변장치는 저속동작을 하며, 브리지를 경유한다
* 메인버스: 주소버스, 데이터버스, 컨트롤버스를 통해 고속 액세스를 수행
    * 주소버스: address가 움직이는 신호선으로, 주소 신호의 경우 cpu로부터 지정 (ex: lw $s4, 0($t0))
    * 데이터버스: 데이터가 오고 가는 신호선
    * 컨트롤버스: 제어를 위한 신호선
    * 그리고 이러한 버스들은 clock을 통해 동기화
* 로컬버스: 저속으로 동작하는 주변장치를 제어하는 신호선
* 브리지: 메인버스와 로컬버스를 연결하는 컨트롤러, 두 버스 간의 속도차를 통제해준다
* UART(Universal Asynchronous Receiver/Transmitter)
    * 직병렬 신호변환에 활용되는 하드웨어다
    * CPU에 병렬 신호 송신(Tx), 수신(Rx)시에는 UART를 통해 이를 직렬로 변환해줘야 한다..?
    * UART끼리 통신할때는 비동기 직렬 통신을 처리한다..는데
      * 통신관련쪽은 일단은 스무스하게 넘어가자.. (통신 공부도 필요해 보이네용)
* I2C
    * 시리얼 제어 버스로서 시리얼 클럭과 양방향 실리얼 데이터, 총 2개의 신호선을 사용하여 통신하는 동기식 직렬 통신이다.
    * 마스터 장치와 슬레이브 장치의 관계가 있어, 복수의 슬레이브 장치에 접속할 수 있다
    * 터치센서나 가속도 센서 등 센서 디바이스 접속에 자주 이용된다
* SPI
    * SCK(Serial Clock)과 단반향의 시리얼 데이터 인, 시리얼 데이터 아웃의 세 가지 신호선으로 통신하는 동기식 직렬 통신
    * I2C와 마찬가지로 복수의 슬레이브에 접속할 수 있지만, 슬레이브 디바이스를 선택하려면 슬레이브 셀렉트를 이용해야 한다
    * 스토리지와 CPU 간의 통신에 이용된다
* I2C와 SPI 둘 다 GND가 있다
* 주변장치
  * DMA 컨트롤러: 메모리에 액세스하는 주변장치
    * CPU가 메모리의 데이터 읽기쓰기를 실행하는 것을 PIO라고 부른다
    * 이러한 PIO 방식으로 대량의 데이터를 읽고 쓰면 CPU는 다른 처리를 할 수 없다
      * But DMA는 CPU를 사용하지 않고 메모리의 데이터를 읽고 쓴다
      * 이로인해 CPU는 메모리를 읽고 쓰는 도중에도 다른 처리를 할 수 있다
    * 버스에는 데이터가 자유롭게 돌아다니므로, 데이터가 부딪치지 않도록 버스 아비터가 버스 중재를 실시한다
    * 이것도 좀 어렵네...
* 타이머: 타이머 인터럽트를 통해 kernel로의 privilege level 이동 가능 (운영체제에서 배움)
* RTC(Real Time Clock)
    * 시간을 관리하기 위한 주변장치
* GPIO(General Purpose Input/Output)
    * CPU가 외부로부터의 입력 및 출력을 범용으로 입출력할 수 있게하는 포트 (마컴시에서 맛봤는데..)

### CPU
* CPU = PC + Decoder + register + ALU
* PC: 방금 실행한 Instruction의 주소를 저장한다
* 디코더: Instruction을 해독한다
* ALU: 논리 연산을 수행한다, 결과를 레지스터에 반영
* 범용 레지스터: CPU에 내장된 범용 메모리
* 시스템 레지스터: Instruction Register + Address Register + Flag Register(CZNSHI, 마컴시에서 봤다..)
* CPU의 명령 실행: fetch -> decode -> execute -> write back
* 데이터 보관은 범용 레지스터가, 명령 연산 결과는 시스템 레지스터가 보관, 명령 연산 결과는 프로그램의 분기 조건이 된다
* CPU의 명령 종류 세 가지: CPU와 메모리 사이의 데이터 교환 / CPU와 주변장치 사이의 데이터 교환 / CPU안에서의 명령
* 인터럽트
  * 주변장치의 처리 요구를 CPU에 통지하기 위한 신호
  * 인터럽트 신호 받으면 인터럽트 벡터 테이블로 실행이 옮겨진다
  * 인터럽트 번호에 의해 정해진 처리로 점프
  * 타이머 인터럽트 + 외부 인터럽트

* 인터럽트 종류와 인터럽트 벡터
  * 인터럽트 종류에 대응하는 다양한 인터럽트 벡터가 존재한다
  * 인터럽트 벡터에는 처리 자체를 등록하지 않고 처리의 주소를 등록해준다 (즉 interrupt vector에는 handler의 주소가 기록되어 있다)
  * 인터럽트에도 우선순위가 있다
